<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250"><title>S_XLIST</title></head>

<body><h2>Zadanie: dodatkowe operacje na listach</h2>Stworzyæ klasê XList, dostarczaj¹c¹ dodatkowych mo¿liwoœci tworzenia list i operowania na nich.<br>W klasie powinny znaleŸæ siê odpowiednie konstruktory oraz statyczne metody <span style="font-weight: bold; font-style: italic;">of</span>, umo¿liwiaj¹ce tworzenie obiektów XList z innych kolekcji, tablic oraz argumentów podawanych przez przecinki.<br>Dodatkowo pomocnicze metody do tworzenia xlist z napisów: <br><ul><li>ofChars(napis) - zwraca x-listê znaków napisu,</li><li>ofTokens(napis, [ sep ]) - zwraca x-listê symboli napisu, rozdzielonych separatorami z sep (jesœi brak - to bia³ymi znakami).</li></ul>Oprócz tego dostarczyæ metod: <br><ul><li>union(dowolna_kolekcja) &nbsp;- &nbsp;zwraca &nbsp;now¹ x-list z do³¹czan¹ do tej x-list&nbsp; zawartoœci¹ kolekcji,</li><li>diff(dowolna_kolekcja) - zwraca x-list zawieraj¹c¹ te elementy tej x-list, które nie wystêpuj¹ w kolekcji,</li><li>unique() - zwraca now¹ x-list, która&nbsp;zawiera wszystkie niepowtarzaj¹ce siê elementy tej x-list</li><li>permute() - zwraca zbiór permutacji elementów tej x-list,</li><li>combine() - zwraca x-listê list-kombinacji elementów z poszczególnych kolekcji, bêd¹cych elementami tej x-listy </li><li>collect(Function) - zwraca now¹ x-listê, której elemenatmi s¹ wyniki funkcji stosowanej wobec elementów tej x-listy,</li><li>join([sep]) - zwraca napis, bêd¹cy po³¹czeniem elementów tej x-listy, z ewentualnie wstawionym pomiêdzy nie separatorem,</li><li>forEachWithIndex(konsumer_z_dwoma
argumentami: element, index) - do iterowania po liœcie z dostêpem i do
elementów i do ich indeksów.</li></ul><br>Za realizacjê ka¿dej z w/w w³aœciwosci &nbsp;uzyskuje siê odrêbne punkty, tak ¿e mo¿na wykonac tylko czêœæ zadania.<br>Przy tym nale¿y jednak uwa¿aæ, aby przekazany w rozwi¹zaniu plik Main.java nie mia³ b³êdów w kompilacji.<br><br>Klasa Main zawarta w projekcie powinna dobrze wyjaœniaæ sposób realizacji zadania:<br><pre>import java.util.*;<br><br>// Plik Main.java mo¿e byæ dowolnie modyfikowany, <br>// ale punkty uzyskuje siê za w³aœciwe dzialanie poszczególnych pokazanych tu metod klasy XList.<br><br>// Je¿eli nie oprogramujemy wszystkich metod, to z klasy Main nalezy usun¹æ te fragmenty,<br>// które powoduj¹ b³êdy w kompilacji - w przeciwnym razie nie uzyskamy punktów.<br><br>public class Main {<br>  public static void main(String[] args) {<br>    // Pewne dodatkowe zestawy danych<br>    Integer[] ints = { 100, 200, 300 };<br>    Set&lt;Integer&gt; set = new HashSet&lt;&gt;(Arrays.asList(3, 4, 5));<br>    <br>    // Sposoby tworzenia<br>    XList&lt;Integer&gt; list1 = new XList&lt;&gt;(1, 3, 9, 11);<br>    XList&lt;Integer&gt; list2 = XList.of(5, 6, 9);<br>    XList&lt;Integer&gt; list3 = new XList(ints);<br>    XList&lt;Integer&gt; list4 = XList.of(ints);<br>    XList&lt;Integer&gt; list5 = new XList(set);<br>    XList&lt;Integer&gt; list6 = XList.of(set);<br><br>    System.out.println(list1);<br>    System.out.println(list2);<br>    System.out.println(list3);<br>    System.out.println(list4);<br>    System.out.println(list5);<br>    System.out.println(list6);<br>    <br>    // --- i pomocnicze metody do tworzenia z napisów<br>    XList&lt;String&gt; slist1 = XList.charsOf("ala ma kota");<br>    XList&lt;String&gt; slist2 = XList.tokensOf("ala ma kota");<br>    XList&lt;String&gt; slist3 = XList.tokensOf("A-B-C", "-");<br><br>    System.out.println(slist1);<br>    System.out.println(slist2);<br>    System.out.println(slist3);<br><br>    // Metoda union - suma elementów <br>    List&lt;Integer&gt; m1 = list1.union(list2);  // oczywiœcie, mo¿na podstawiaæ na List<br>    System.out.println(m1);<br>    // mo¿na wykonywaæ wszystkie operacje z interfejsu List, np:<br>    m1.add(11);<br>    System.out.println(m1);<br>    XList&lt;Integer&gt; m2 = (XList&lt;Integer&gt;) m1;<br>    XList&lt;Integer&gt; m3 = m2.union(ints).union(XList.of(4, 4));<br>    System.out.println(m2); // m2 siê nie zmienia<br>    System.out.println(m3); // wynik jest w m3<br>    m3 = m3.union(set);<br>    System.out.println(m3);<br>    <br>    // Widzieliœmy metode union<br>    // Teraz metoda diff(dowolna kolekcja)<br>    System.out.println(m3.diff(set));  // wszystko z m3, co nie jest w set<br>    System.out.println(XList.of(set).diff(m3)); // co jest w set, czego nie ma w m3<br>    <br>    // Metoda unique -zwraca now¹ Xlist bez duplikatow   <br>    XList&lt;Integer&gt; uniq = m3.unique(); // lista, nie Set<br>    System.out.println(uniq);<br>    <br>    // permutacje (kolejnoœæ nie jest istotna, wa¿ne ¿eby efektywnie)<br>    Set&lt;String&gt; perm1 = XList.charsOf("abc").permute();<br>    System.out.println(perm1);<br>    Set&lt;Integer&gt; perm2 = XList.of(1,2,3).permute();<br>    System.out.println(perm2);<br>    <br>    // kombinacje (kolejnoœæ jest istotna)<br>    List&lt;String&gt; sa = Arrays.asList( "a", "b");<br>    List&lt;String&gt; sb = Arrays.asList( "X", "Y", "Z" );<br>    XList&lt;String&gt; sc = XList.charsOf( "12" );<br>    XList toCombine = XList.of(sa, sb, sc);  // czy mo¿na tu unikn¹æ u¿ycia typu surowego?<br>    System.out.println(toCombine);<br>    XList&lt;XList&lt;String&gt;&gt; cres = toCombine.combine();<br>    System.out.println(cres);<br><br>    // collect i join<br>    XList&lt;String&gt; j1 = cres.collect( list -&gt; list.join());<br>    System.out.println(j1.join(" "));<br>    XList&lt;String&gt; j2 =cres.collect( list -&gt; list.join("-"));<br>    System.out.println(j2.join(" "));<br>    <br>    // forEachWithIndex<br>    XList&lt;Integer&gt; lmod = XList.of(1,2,8, 10, 11, 30, 3, 4);  <br>    lmod.forEachWithIndex( (e, i) -&gt; lmod.set(i, e*2));<br>    System.out.println(lmod);<br>    lmod.forEachWithIndex( (e, i) -&gt; { if (i % 2 == 0) lmod.remove(e); } );<br>    System.out.println(lmod);<br>    lmod.forEachWithIndex( (e, i) -&gt; { if (i % 2 == 0) lmod.remove(i); } );<br>    System.out.println(lmod); // Pytanie: dlaczego mamy taki efekt? <br><br>  }<br>}</pre>Ten program wypisuje na konsoli:<br><br>[1, 3, 9, 11]<br>[5, 6, 9]<br>[100, 200, 300]<br>[100, 200, 300]<br>[3, 4, 5]<br>[3, 4, 5]<br>[a, l, a,&nbsp; , m, a,&nbsp; , k, o, t, a]<br>[ala, ma, kota]<br>[A, B, C]<br>[1, 3, 9, 11, 5, 6, 9]<br>[1, 3, 9, 11, 5, 6, 9, 11]<br>[1, 3, 9, 11, 5, 6, 9, 11]<br>[1, 3, 9, 11, 5, 6, 9, 11, 100, 200, 300, 4, 4]<br>[1, 3, 9, 11, 5, 6, 9, 11, 100, 200, 300, 4, 4, 3, 4, 5]<br>[1, 9, 11, 6, 9, 11, 100, 200, 300]<br>[]<br>[1, 3, 9, 11, 5, 6, 100, 200, 300, 4]<br>[[a, b, c], [c, b, a], [b, a, c], [c, a, b], [a, c, b], [b, c, a]]<br>[[1, 2, 3], [3, 2, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [2, 3, 1]]<br>[[a, b], [X, Y, Z], [1, 2]]<br>[[a,
X, 1], [b, X, 1], [a, Y, 1], [b, Y, 1], [a, Z, 1], [b, Z, 1], [a, X,
2], [b, X, 2], [a, Y, 2], [b, Y, 2], [a, Z, 2], [b, Z, 2]]<br>aX1 bX1 aY1 bY1 aZ1 bZ1 aX2 bX2 aY2 bY2 aZ2 bZ2<br>a-X-1 b-X-1 a-Y-1 b-Y-1 a-Z-1 b-Z-1 a-X-2 b-X-2 a-Y-2 b-Y-2 a-Z-2 b-Z-2<br>[2, 4, 16, 20, 22, 60, 6, 8]<br>[4, 16, 22, 60, 8]<br>[16, 22, 60, 8]<br><br><br>
</body></html>